[{
  "_id": {
    "$oid": "675b2e279a0ce90cfd22c8c6"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": ".gitattributes",
  "caminho": ".",
  "conteudo": "# Auto detect text files and perform LF normalization\n* text=auto\n",
  "tipo": "estatico",
  "prompt": "Desenvolva um sistema que identifique automaticamente arquivos de texto em um projeto e aplique a normalização de final de linha para o formato LF (Line Feed). O sistema deve ser capaz de reconhecer diferentes tipos de arquivos de texto e garantir que todos eles utilizem o mesmo padrão de final de linha, promovendo consistência e evitando problemas de formatação em ambientes de desenvolvimento colaborativo.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 10,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e299a0ce90cfd22c8c8"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": ".gitignore",
  "caminho": ".",
  "conteudo": "# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\nlerna-debug.log*\n.pnpm-debug.log*\n\n# Diagnostic reports (https://nodejs.org/api/report.html)\nreport.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json\n\n# Runtime data\npids\n*.pid\n*.seed\n*.pid.lock\n\n# Directory for instrumented libs generated by jscoverage/JSCover\nlib-cov\n\n# Coverage directory used by tools like istanbul\ncoverage\n*.lcov\n\n# nyc test coverage\n.nyc_output\n\n# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n\n# Bower dependency directory (https://bower.io/)\nbower_components\n\n# node-waf configuration\n.lock-wscript\n\n# Compiled binary addons (https://nodejs.org/api/addons.html)\nbuild/Release\n\n# Dependency directories\nnode_modules/\njspm_packages/\n\n# Snowpack dependency directory (https://snowpack.dev/)\nweb_modules/\n\n# TypeScript cache\n*.tsbuildinfo\n\n# Optional npm cache directory\n.npm\n\n# Optional eslint cache\n.eslintcache\n\n# Optional stylelint cache\n.stylelintcache\n\n# Microbundle cache\n.rpt2_cache/\n.rts2_cache_cjs/\n.rts2_cache_es/\n.rts2_cache_umd/\n\n# Optional REPL history\n.node_repl_history\n\n# Output of 'npm pack'\n*.tgz\n\n# Yarn Integrity file\n.yarn-integrity\n\n# dotenv environment variable files\n.env\n.env.development.local\n.env.test.local\n.env.production.local\n.env.local\n\n# parcel-bundler cache (https://parceljs.org/)\n.cache\n.parcel-cache\n\n# Next.js build output\n.next\nout\n\n# Nuxt.js build / generate output\n.nuxt\ndist\n\n# Gatsby files\n.cache/\n# Comment in the public line in if your project uses Gatsby and not Next.js\n# https://nextjs.org/blog/next-9-1#public-directory-support\n# public\n\n# vuepress build output\n.vuepress/dist\n\n# vuepress v2.x temp and cache directory\n.temp\n.cache\n\n# Docusaurus cache and generated files\n.docusaurus\n\n# Serverless directories\n.serverless/\n\n# FuseBox cache\n.fusebox/\n\n# DynamoDB Local files\n.dynamodb/\n\n# TernJS port file\n.tern-port\n\n# Stores VSCode versions used for testing VSCode extensions\n.vscode-test\n\n# yarn v2\n.yarn/cache\n.yarn/unplugged\n.yarn/build-state.yml\n.yarn/install-state.gz\n.pnp.*\n",
  "tipo": "estatico",
  "prompt": "Crie um arquivo de configuração que define quais arquivos e diretórios devem ser ignorados em um projeto, especificando padrões para logs, relatórios de diagnóstico, dados de execução, diretórios de dependências, caches de ferramentas de desenvolvimento, arquivos de ambiente, saídas de construção de frameworks e bibliotecas, e outros arquivos temporários ou gerados. O objetivo é manter o repositório limpo e evitar o versionamento de arquivos desnecessários que não são relevantes para o código-fonte principal.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 20,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e2a9a0ce90cfd22c8ca"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "LICENSE",
  "caminho": ".",
  "conteudo": "MIT License\n\nCopyright (c) 2024 Fabio\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
  "tipo": "estatico",
  "prompt": "Descreva um documento de licença que concede permissão irrestrita para usar, copiar, modificar, mesclar, publicar, distribuir, sublicenciar e vender um software, desde que a notificação de copyright e a permissão sejam incluídas em todas as cópias. O documento também isenta os autores de qualquer responsabilidade por danos ou reivindicações relacionadas ao uso do software, apresentando-o \"como está\" e sem garantias de qualquer tipo.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 30,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e2f9a0ce90cfd22c8cc"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "README.md",
  "caminho": ".",
  "conteudo": "# Gerador de Código para Micro-Serviços e Micro-Frontend usando ChatGPT\n\nEste projeto utiliza o ChatGPT para gerar código para micro-serviços e micro-frontends, facilitando a criação e manutenção de aplicações escaláveis e modulares.\n\n## Índice\n\n1. [Estrutura do Projeto](#estrutura-do-projeto)\n2. [Tipos de Arquivos](#tipos-de-arquivos)\n3. [Como Usar](#como-usar)\n4. [Dependências](#dependências)\n5. [Licença](#licença)\n\n## Estrutura do Projeto\n\nA organização do projeto está dividida entre backend e frontend, com diretórios específicos para documentação, seeds e controladores.\n\n```\n├── backend\n│   ├── docs\n│   │   └── Exemplos de descrições de formulários\n│   ├── seeds\n│   │   ├── projeto\n│   │   │   └── Exemplo do backend com o prompt\n│   │   └── arquivos\n│   │       └── Prompts para geração de cada arquivo\n│   └── src\n│       └── Outras partes de prompts\n├── frontend\n│   └── [Diretórios e arquivos do frontend]\n├── .env\n├── package.json\n└── LICENSE\n```\n\n- **backend/docs**: Contém exemplos de descrições de formulários que auxiliam na geração de código.\n- **backend/seeds**:\n  - **projeto**: Exemplo do backend configurado com o prompt necessário.\n  - **arquivos**: Prompts específicos para a geração de cada arquivo do backend.\n- **backend/controllers/codeGeneratorController.js**: Gerador com mais prompts utilizadas no processo de geração.\n\n## Tipos de Arquivos\n\nOs arquivos gerados pelo projeto são classificados em dois tipos:\n\n1. **Estáticos**: Arquivos que são criados sempre com o mesmo conteúdo, independentemente do contexto ou das entradas fornecidas.\n2. **Dinâmicos**: Arquivos gerados pelo ChatGPT com base nos prompts fornecidos, adaptando-se às necessidades específicas do projeto.\n\n## Como Usar\n\nSiga os passos abaixo para configurar e utilizar o gerador de código:\n\n1. **Configuração das Variáveis de Ambiente**:\n   - Renomeie o arquivo `.env.example` para `.env`.\n   - Insira suas variáveis de ambiente, incluindo a API-Key da OpenAI.\n\n2. **Importação dos Seeds para o Banco de Dados**:\n   - Execute os scripts de seed presentes no diretório `backend/seeds` para popular o banco de dados com os prompts necessários.\n\n3. **Execução do Serviço Backend**:\n   - Navegue até o diretório `backend` e instale as dependências com `npm install`.\n   - Inicie o backend com `npm run dev` ou o comando correspondente.\n\n4. **Execução do Frontend**:\n   - Navegue até o diretório `frontend` e instale as dependências com `npm install`.\n   - Inicie o frontend com `npm run dev` ou o comando correspondente.\n\n5. **Descrição dos Campos e Validações no Frontend**:\n   - Acesse o formulário no frontend.\n   - Descreva os campos e as validações necessárias. Exemplo disponível no diretório `backend/docs`.\n\n6. **Geração do Código**:\n   - Após descrever os campos, clique em **Gerar Código**.\n   - O sistema utilizará os prompts para gerar os arquivos necessários no diretorio `backend/generated`.\n\n7. **Criação e Teste dos Projetos**:\n   - Crie seus projetos seguindo a arquitetura sugerida.\n   - Teste os prompts para garantir que os arquivos são gerados conforme esperado.\n\n8. **Melhorias e Compartilhamento**:\n   - Revise o código gerado e faça as melhorias que considerar importantes.\n   - Compartilhe suas contribuições para aprimorar o projeto.\n\n## Dependências\n\nCertifique-se de instalar todas as dependências listadas nos arquivos `package.json` dos diretórios `backend` e `frontend`. Utilize o seguinte comando em cada diretório:\n\n```bash\nnpm install\n```\n\n## Licença\n\nEste projeto está licenciado sob a licença MIT. Consulte o arquivo [LICENSE](LICENSE) para mais detalhes.\n\n---\n\nEsperamos que este gerador de código facilite o desenvolvimento de seus micro-serviços e micro-frontends. Para quaisquer dúvidas ou contribuições, sinta-se à vontade para abrir uma issue ou enviar um pull request.",
  "tipo": "estatico",
  "prompt": "Desenvolva um gerador de código que utilize o ChatGPT para criar micro-serviços e micro-frontends, organizando o projeto em diretórios distintos para backend e frontend. O sistema deve incluir documentação com exemplos de formulários, seeds para popular o banco de dados com prompts, e um controlador para a geração de código. Classifique os arquivos gerados em estáticos e dinâmicos, e forneça um guia passo a passo para configuração, execução e geração de código, incluindo a descrição de campos e validações no frontend. Assegure-se de que todas as dependências sejam instaladas e que o projeto esteja licenciado sob a licença MIT.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 40,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e309a0ce90cfd22c8ce"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": ".env",
  "caminho": "backend",
  "conteudo": "PORT=5000\n\nDB_SERVER=mongodb://localhost:27017\nDB_USER=admin\nDB_PASSWORD=senha123\nDB_NAME=gerador-de-codigo\nDB_AUTH_SOURCE=admin\nDB_REPLICA_SET=\nDB_TSL=\n\nOPENAI_API_KEY=sk-svcacct-8_IgrgjyirxpYgbylYEaLIbvuIzDDFxSpLN80vCAseRFOeqJo7W0kRIv8g1o0kT3BlbkFJ8SEsmHUeBM7Sl67zR2SskqE70w_5C79vrYTbf5Xkgz3b-4vJwflzoxMzXRl7gA\n\n",
  "tipo": "estatico",
  "prompt": "O arquivo contém configurações de ambiente para um projeto, incluindo a definição da porta do servidor, detalhes de conexão com um banco de dados MongoDB, como servidor, usuário, senha, nome do banco de dados e informações de autenticação. Além disso, inclui uma chave de API para acesso à OpenAI. Essas variáveis são essenciais para a configuração e operação do aplicativo, permitindo a comunicação com o banco de dados e serviços externos.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 50,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e329a0ce90cfd22c8d0"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": ".env.dev",
  "caminho": "backend",
  "conteudo": "PORT=5000\n\nDB_SERVER=mongodb://localhost:27017\nDB_USER=admin\nDB_PASSWORD=senha123\nDB_NAME=gerador-de-codigo\nDB_AUTH_SOURCE=admin\nDB_REPLICA_SET=\nDB_TSL=\n\nOPENAI_API_KEY=\n",
  "tipo": "estatico",
  "prompt": "Crie um arquivo de configuração para um aplicativo que define variáveis de ambiente essenciais. Especifique a porta do servidor como 5000. Inclua as informações de conexão com um banco de dados MongoDB, como o endereço do servidor, nome de usuário, senha, nome do banco de dados e fonte de autenticação. Deixe os campos para o conjunto de réplicas e TSL em branco. Adicione também uma chave de API para o OpenAI, que deve ser deixada vazia.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 60,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e339a0ce90cfd22c8d2"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": ".gitignore",
  "caminho": "backend",
  "conteudo": "# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n\n# Diretorio de codigos gerados\ngenerated",
  "tipo": "estatico",
  "prompt": "Crie um arquivo de configuração para ignorar arquivos e diretórios específicos em um projeto, incluindo logs de execução, diretórios de dependências, arquivos de configuração de editores e diretórios de código gerado. O arquivo deve especificar que todos os arquivos com a extensão .log, bem como diretórios como node_modules e dist, devem ser ignorados. Além disso, deve incluir regras para ignorar arquivos e diretórios relacionados a editores de código, como .vscode e .idea, enquanto permite a inclusão de um arquivo específico dentro do diretório .vscode. O objetivo é manter o repositório limpo, evitando o versionamento de arquivos desnecessários e temporários.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 70,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e369a0ce90cfd22c8d4"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "exemplo-requisicao.md",
  "caminho": "backend/docs",
  "conteudo": "nome: \"Prestador\",\nexemplo de descrição: Dados Gerais: SID, numerico com 7 digitos, Código SCI, com 7 numeros, status (ativo, em analise, pendente de revisão, inativo, arquivado), tipo (Pessoa Fisica ou Juridica), nome (obrigatório), email, nome da mae, data de nascimento, pis, rg, orgao emissor do rg; Endereco: Cep, Rua, Numero, Complemento, Cidade, Estado; Dados Bancários: Tipo de Conta (Corrente ou Poupança), Banco, Agencia, Conta, Comentarios de Revisão",
  "tipo": "estatico",
  "prompt": "Desenvolva um modelo de dados para um prestador de serviços que inclua informações gerais como SID (um número único de 7 dígitos), Código SCI (também um número de 7 dígitos), status (com opções como ativo, em análise, pendente de revisão, inativo e arquivado), tipo de prestador (Pessoa Física ou Jurídica), nome (campo obrigatório), email, nome da mãe, data de nascimento, PIS, RG e órgão emissor do RG. Além disso, inclua informações de endereço, que devem conter CEP, rua, número, complemento, cidade e estado. Por fim, adicione dados bancários que especifiquem o tipo de conta (corrente ou poupança), banco, agência, número da conta e um campo para comentários de revisão.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 80,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e389a0ce90cfd22c8d6"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "package.json",
  "caminho": "backend",
  "conteudo": "{\n  \"name\": \"backend\",\n  \"version\": \"1.0.0\",\n  \"main\": \"src/server.js\",\n  \"scripts\": {\n    \"dev\": \"nodemon src/server.js\",\n    \"start\": \"node src/server.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"description\": \"\",\n  \"dependencies\": {\n    \"cors\": \"^2.8.5\",\n    \"dotenv\": \"^16.4.7\",\n    \"express\": \"^4.21.2\",\n    \"mongoose\": \"^8.8.4\",\n    \"node-fetch\": \"^3.3.2\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.1.7\"\n  }\n}\n",
  "tipo": "estatico",
  "prompt": "Descreva um projeto de backend em JavaScript que utiliza Node.js como ambiente de execução. O projeto possui um arquivo principal localizado em \"src/server.js\" e inclui scripts para desenvolvimento, inicialização e testes. As dependências do projeto incluem bibliotecas para gerenciamento de variáveis de ambiente, criação de servidores web, manipulação de dados com MongoDB e requisições HTTP. Além disso, o projeto utiliza uma ferramenta de desenvolvimento que reinicia automaticamente o servidor durante o desenvolvimento. O projeto não possui informações sobre autor, descrição ou palavras-chave.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 90,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e3a9a0ce90cfd22c8d8"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "gerador-de-codigo.arquivos.json",
  "caminho": "backend/seeds",
  "conteudo": "[{\n  \"_id\": {\n    \"$oid\": \"6754ce05760eb6acd676c663\"\n  },\n  \"projeto\": {\n    \"$oid\": \"6754cd3f760eb6acd676c65e\"\n  },\n  \"nome\": \"Controller.js\",\n  \"caminho\": \"src/controllers\",\n  \"tipo\": \"dinamico\",\n  \"nomeConcatenado\": true,\n  \"camelCase\": true,\n  \"prompt\": \"gere o código do Controller com todos os verbos\",\n  \"ordem\": 40\n},\n{\n  \"_id\": {\n    \"$oid\": \"675598a9760eb6acd676c68b\"\n  },\n  \"projeto\": {\n    \"$oid\": \"6754cd3f760eb6acd676c65e\"\n  },\n  \"nome\": \"server.js\",\n  \"caminho\": \"src/\",\n  \"tipo\": \"estatico\",\n  \"nomeConcatenado\": false,\n  \"camelCase\": false,\n  \"conteudo\": \"const app = require('./app');\\nconst PORT = process.env.PORT;\\n\\napp.listen(PORT, () => {\\n  console.log(`Servidor rodando na porta ${PORT}`);\\n});\\n\",\n  \"ordem\": 10\n},\n{\n  \"_id\": {\n    \"$oid\": \"67559bdf760eb6acd676c68e\"\n  },\n  \"projeto\": {\n    \"$oid\": \"6754cd3f760eb6acd676c65e\"\n  },\n  \"nome\": \"Routes.js\",\n  \"caminho\": \"src/routes\",\n  \"tipo\": \"dinamico\",\n  \"nomeConcatenado\": true,\n  \"camelCase\": true,\n  \"prompt\": \"gere o código da Routers com todos os verbos\",\n  \"ordem\": 50\n},\n{\n  \"_id\": {\n    \"$oid\": \"67559bec760eb6acd676c68f\"\n  },\n  \"projeto\": {\n    \"$oid\": \"6754cd3f760eb6acd676c65e\"\n  },\n  \"nome\": \"app.js\",\n  \"caminho\": \"src/\",\n  \"tipo\": \"dinamico\",\n  \"nomeConcatenado\": false,\n  \"camelCase\": false,\n  \"ordem\": 80,\n  \"prompt\": \"gere o app, usando cors, helmet e winston, testando a conexão com o DB\"\n},\n{\n  \"_id\": {\n    \"$oid\": \"6755b37f760eb6acd676c692\"\n  },\n  \"projeto\": {\n    \"$oid\": \"6754cd3f760eb6acd676c65e\"\n  },\n  \"nome\": \".js\",\n  \"caminho\": \"src/models\",\n  \"tipo\": \"dinamico\",\n  \"nomeConcatenado\": true,\n  \"camelCase\": false,\n  \"prompt\": \"gere o código da Model com as validações\",\n  \"ordem\": 25\n},\n{\n  \"_id\": {\n    \"$oid\": \"6755bba2760eb6acd676c693\"\n  },\n  \"projeto\": {\n    \"$oid\": \"6754cd3f760eb6acd676c65e\"\n  },\n  \"nome\": \"package.json\",\n  \"caminho\": \"\",\n  \"tipo\": \"dinamico\",\n  \"nomeConcatenado\": false,\n  \"camelCase\": false,\n  \"prompt\": \"gere o package.json com as dependencias necessárias\",\n  \"ordem\": 100\n},\n{\n  \"_id\": {\n    \"$oid\": \"6755bbd0760eb6acd676c694\"\n  },\n  \"projeto\": {\n    \"$oid\": \"6754cd3f760eb6acd676c65e\"\n  },\n  \"nome\": \".env\",\n  \"caminho\": \"\",\n  \"tipo\": \"dinamico\",\n  \"nomeConcatenado\": false,\n  \"camelCase\": false,\n  \"ordem\": 95,\n  \"prompt\": \"gere o .env\"\n},\n{\n  \"_id\": {\n    \"$oid\": \"6755bc92760eb6acd676c695\"\n  },\n  \"projeto\": {\n    \"$oid\": \"6754cd3f760eb6acd676c65e\"\n  },\n  \"nome\": \"db.js\",\n  \"caminho\": \"src/\",\n  \"tipo\": \"estatico\",\n  \"nomeConcatenado\": false,\n  \"camelCase\": false,\n  \"conteudo\": \"const mongoose = require(\\\"mongoose\\\");\\n\\nconst config = {\\n  dbServer: process.env.DB_SERVER,\\n  dbUser: process.env.DB_USER,\\n  dbPassword: process.env.DB_PASSWORD,\\n  dbName: process.env.DB_NAME,\\n  dbAuthSource: process.env.DB_AUTH_SOURCE,\\n  dbReplicaSet: process.env.DB_REPLICA_SET,\\n  dbTsl: process.env.DB_TSL,\\n};\\n\\nlet mongoUri = `${config.dbServer}/${config.dbName}?`;\\nif (config.dbAuthSource) mongoUri += `authSource=${config.dbAuthSource}&`;\\nif (config.dbTsl) mongoUri += `tls=true&`;\\nif (config.dbReplicaSet) mongoUri += `replicaSet=${config.dbReplicaSet}`;\\n\\nconst connectDB = async () => {\\n  try {\\n    await mongoose.connect(mongoUri, {\\n      user: config.dbUser,\\n      pass: config.dbPassword,\\n    });\\n    console.log(`Conectado ao MongoDB`);\\n    console.log(` - Server: ${config.dbServer}`);\\n    console.log(` - User: ${config.dbUser}`);\\n    console.log(` - Database: ${config.dbName}`);\\n  } catch (err) {\\n    console.error(`Erro ao conectar ao MongoDB ${config.dbName}`, err);\\n    process.exit(1); // Encerra o processo com falha\\n  }\\n};\\n\\nmodule.exports = { connectDB };\\n\",\n  \"ordem\": 15\n}]",
  "tipo": "estatico",
  "prompt": "Desenvolva um projeto de aplicação web que inclua os seguintes componentes: um controlador dinâmico que gere código para manipulação de verbos, um servidor que inicie a aplicação em uma porta especificada, rotas dinâmicas que também gerem código para verbos, um aplicativo que utilize as bibliotecas cors, helmet e winston, além de testar a conexão com um banco de dados. Inclua um modelo dinâmico com validações, um arquivo package.json que contenha as dependências necessárias, um arquivo .env para variáveis de ambiente, e um módulo de conexão com o MongoDB que construa a URI de conexão com base em variáveis de ambiente e trate erros de conexão. Organize os arquivos de acordo com suas respectivas pastas e defina a ordem de execução dos componentes.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 100,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e3c9a0ce90cfd22c8da"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "gerador-de-codigo.projetos.json",
  "caminho": "backend/seeds",
  "conteudo": "[{\n  \"_id\": {\n    \"$oid\": \"6754cd3f760eb6acd676c65e\"\n  },\n  \"nome\": \"backend\",\n  \"status\": \"ativo\",\n  \"prompt\": \"Gerador de Código para o desenvolvimento de um Micro-Serviço usando NodeJs e MongoDb; O projeto segue o padrão RestFull com todos os verbos; O Listar deve suportar o filtro de qualquer campo passado na Query.\"\n}]",
  "tipo": "estatico",
  "prompt": "Desenvolva um gerador de código para a criação de um micro-serviço utilizando Node.js e MongoDB. O serviço deve seguir o padrão RESTful, implementando todos os verbos HTTP. A funcionalidade de listagem deve permitir a filtragem de registros com base em qualquer campo especificado na consulta. O projeto deve estar ativo e ser identificado pelo nome \"backend\".",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 110,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e3d9a0ce90cfd22c8dc"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "app.js",
  "caminho": "backend/src",
  "conteudo": "require('dotenv').config();\nconst express = require('express');\nconst cors = require('cors');\nconst { connectDB } = require('./db');\n\nconst app = express();\n\nconnectDB();\n\napp.use(cors());\napp.use(express.json());\n\napp.use('/generate-code', require('./routes/codeGeneratorRoutes'));\napp.use(\"/clonar-codigo\", require(\"./routes/clonarCodigoRoutes\"));\napp.use(\"/arquivos\", require(\"./routes/arquivoRoutes\"));\napp.use(\"/projetos\", require(\"./routes/projetoRoutes\"));\n\n\n\nmodule.exports = app;\n",
  "tipo": "estatico",
  "prompt": "Desenvolva uma aplicação web utilizando o framework Express que se conecta a um banco de dados, configurando variáveis de ambiente a partir de um arquivo .env. A aplicação deve permitir o uso de CORS e aceitar requisições JSON. Implemente rotas específicas para geração de código, clonagem de código, manipulação de arquivos e gerenciamento de projetos, organizando cada funcionalidade em módulos separados. A aplicação deve ser exportada para ser utilizada em outros arquivos.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 120,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e3f9a0ce90cfd22c8de"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "clonarCodigoController.js",
  "caminho": "backend/src/controllers",
  "conteudo": "const fs = require('fs').promises;\nconst path = require('path');\nconst Arquivo = require('../models/Arquivo');\nconst Projeto = require('../models/Projeto');\nconst { generateCode } = require('../services/chatGptService'); // Função que chama o GPT-4\n\nexports.clonarCodigo = async (req, res) => {\n  try {\n    const { caminho } = req.body;\n    if (!caminho) {\n      return res.status(400).json({ error: 'caminho é obrigatório.' });\n    }\n\n    const projectName = path.basename(caminho);\n    const projetoPrompt = `Projeto clonado do código existente no caminho: ${caminho}. Futuramente será convertido em um prompt de alto nível.`;\n\n    const projeto = new Projeto({\n      nome: projectName,\n      status: 'ativo',\n      prompt: projetoPrompt\n    });\n    await projeto.save();\n\n    let ordem = 10;\n\n    async function mapearArquivos(basePath, currentPath = '') {\n      const dirPath = path.join(basePath, currentPath);\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\n\n      const ignoreFiles = [\"node_modules\", \"package-lock.json\", \"public\", \"license\", \".git\", \".vscode\", \"assets\"]\n\n      for (const entry of entries) {\n        const fullPath = path.join(dirPath, entry.name);\n\n        console.log(\"ENTRY ->\", entry.name);\n        \n\n        if(!ignoreFiles.includes(entry.name)){\n          console.log(\"PROCESSANDO\", entry.name);\n          \n          if (entry.isDirectory()) {\n            await mapearArquivos(basePath, path.join(currentPath, entry.name));\n          } else {\n            const conteudo = await fs.readFile(fullPath, 'utf8');\n\n            const messages = [\n              {\n                role: 'system',\n                content: 'Você é um assistente que transforma código em um prompt descritivo de alto nível. Não precisa ter explicações do que é, apenas a especificação para fazer o caminho reverso do prompt para o código. Sempre responda apenas com o prompt, sem usar blocos de código Markdown, sem explicações adicionais, sem comentários. O prompt deve descrever o que o código faz, suas regras e propósito de forma abstrata e clara.'\n              },\n              {\n                role: 'user',\n                content: `Abaixo está o conteúdo de um arquivo do projeto clonado. Gere exclusivamente um prompt descritivo, sem código, sem comentários:\\n${conteudo}`\n              }\n            ];\n\n            try {\n              const arquivoPromptGerado = await generateCode(messages);\n\n              const novoArquivo = new Arquivo({\n                projeto: projeto._id,\n                nome: entry.name,\n                caminho: currentPath || '.',  // <- Ajuste aqui\n                conteudo: conteudo || \"\",\n                tipo: 'estatico',\n                prompt: arquivoPromptGerado.trim(),\n                pascalCase: false,\n                nomeConcatenado: false,\n                ordem: ordem\n              });\n\n              console.log(\"\\n---------------------------------------------------\");\n              console.log(`Arquivo ${entry.name} mapeado com sucesso!`);\n              console.log(novoArquivo);\n              \n              await novoArquivo.save();\n\n              ordem += 10;\n            } catch (error) {\n              console.error(`Erro ao gerar prompt para o arquivo ${entry.name}:`, error);\n              // Opcional: Continue processando outros arquivos ou interrompa\n            }\n          }\n          }\n      }\n    }\n\n    await mapearArquivos(caminho);\n    console.log(\"Arquivos processados\");\n    \n\n    res.status(201).json({ message: 'Projeto e arquivos clonados com sucesso, prompts gerados!', projetoId: projeto._id });\n  } catch (error) {\n    console.error('Erro ao clonar código:', error);\n    res.status(500).json({ error: 'Erro interno ao clonar o código.' });\n  }\n};\n",
  "tipo": "estatico",
  "prompt": "Desenvolva uma função assíncrona que clona um projeto a partir de um caminho fornecido, criando um novo registro de projeto e mapeando todos os arquivos contidos nesse caminho, exceto aqueles que estão na lista de exclusão. Para cada arquivo, leia seu conteúdo e gere um prompt descritivo utilizando um serviço de geração de código, armazenando o resultado em um novo registro de arquivo associado ao projeto. A função deve lidar com erros adequadamente, retornando mensagens apropriadas em caso de falhas, e deve garantir que o projeto e os arquivos sejam salvos no banco de dados com informações relevantes, como nome, caminho e status.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 130,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e429a0ce90cfd22c8e0"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "codeGeneratorController.js",
  "caminho": "backend/src/controllers",
  "conteudo": "const fs = require('fs').promises;\nconst path = require('path');\nconst Projeto = require('../models/Projeto');\nconst Arquivo = require('../models/Arquivo');\nconst { generateCode } = require('../services/chatGptService');\nconst { toCamelCase, removeCodeBlockMarkers } = require('../utils/namingUtils');\nconst { ensureDirExists } = require('../utils/fileUtils');\n\nexports.createCode = async (req, res) => {\n  try {\n    const { projetoId, nome, prompt } = req.body;\n\n    if (!projetoId) {\n      return res.status(400).json({ error: 'projetoId são obrigatórios.' });\n    }\n\n    const projeto = await Projeto.findOne({ _id: projetoId, status: 'ativo' });\n    if (!projeto) {\n      return res.status(404).json({ error: `Nenhum projeto ativo encontrado para o projetoId ${projetoId}.` });\n    }\n\n    const arquivos = await Arquivo.find({ projeto: projeto._id }).sort({ ordem: 1 });\n    const generatedFilePaths = [];\n\n    // Mensagens base\n    let messages = [\n      {\n        role: 'system',\n        content: 'Você é um assistente de geração de código. Sempre responda apenas com o código necessário, sem usar blocos de código Markdown, sem explicações, sem comentários e sem texto adicional; Atenção sempre aos nomes e diretorios dos arquivos gerados para manter a concistência do projeto.'\n      },\n      {\n        role: 'user',\n        content: `Projeto: ${projeto.nome} ${nome}\\nDescrição: ${projeto.prompt}\\nInstruções Adicionais: ${prompt}`\n      }\n    ];\n    console.log(\"prompt:\", messages);\n\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n    for (const arquivo of arquivos) {\n      let code;\n\n      let fileName = arquivo.nome;\n      if (arquivo.nomeConcatenado) {\n        fileName = `${nome}${arquivo.nome}`;\n      }\n      if (arquivo.camelCase) {\n        fileName = toCamelCase(fileName);\n      }\n      console.log(\"fileName:\", fileName);\n\n      const fileDir = path.join(__dirname, `../../generated/${nome}-${toCamelCase(projeto.nome)}-${timestamp}/${arquivo.caminho}`);\n      const filePath = path.join(fileDir, fileName);\n\n      if (arquivo.tipo === 'dinamico') {\n        const arquivoPrompt = {\n          role: 'user',\n          content: `Gere o código para o arquivo ${fileName} com as seguintes especificações:\\n${arquivo.prompt}\\nNão use blocos de código, não explique, não comente.`\n        };\n        console.log(\"prompt:\", arquivoPrompt);\n\n        const currentMessages = [...messages, arquivoPrompt];\n        code = await generateCode(currentMessages);\n\n        // Remove marcadores de código se houver\n        code = removeCodeBlockMarkers(code);\n      } else if (arquivo.tipo === 'estatico') {\n        code = arquivo.conteudo;\n      }\n\n      // Adiciona o código gerado ao histórico, incluindo caminho e nome do arquivo\n      mensagemCodigoGerado = {\n        role: 'user',\n        content: `lembre do código gerado para ${arquivo.caminho}/${fileName}: ${code}`\n      };\n      messages.push(mensagemCodigoGerado);\n      console.log(\"mensagemCodigoGerado:\", mensagemCodigoGerado);\n\n      await ensureDirExists(fileDir);\n      await fs.writeFile(filePath, code, 'utf8');\n      generatedFilePaths.push(filePath);\n    }\n\n    res.status(200).json({ message: 'Código gerado com sucesso!', filePaths: generatedFilePaths });\n  } catch (error) {\n    console.error('Erro ao gerar código:', error);\n    res.status(500).json({ error: 'Erro interno ao gerar o código.' });\n  }\n};\n",
  "tipo": "estatico",
  "prompt": "Desenvolva uma função que cria código a partir de um projeto existente, recebendo um ID de projeto, um nome e um prompt através de uma requisição. A função deve validar a existência de um projeto ativo correspondente ao ID fornecido e buscar todos os arquivos associados a esse projeto, ordenando-os. Para cada arquivo, a função deve gerar um nome de arquivo apropriado, possivelmente aplicando formatação em camel case, e determinar o diretório onde o arquivo será salvo. Dependendo do tipo de arquivo (dinâmico ou estático), a função deve gerar o código usando um serviço de geração de código ou utilizar o conteúdo estático do arquivo. O código gerado deve ser salvo no diretório especificado, e a função deve manter um histórico das mensagens de geração de código. Por fim, a função deve retornar uma resposta JSON com uma mensagem de sucesso e os caminhos dos arquivos gerados, ou um erro em caso de falha.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 140,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e449a0ce90cfd22c8e2"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "db.js",
  "caminho": "backend/src",
  "conteudo": "const mongoose = require(\"mongoose\");\n\nconst config = {\n  dbServer: process.env.DB_SERVER,\n  dbUser: process.env.DB_USER,\n  dbPassword: process.env.DB_PASSWORD,\n  dbName: process.env.DB_NAME,\n  dbAuthSource: process.env.DB_AUTH_SOURCE,\n  dbReplicaSet: process.env.DB_REPLICA_SET,\n  dbTsl: process.env.DB_TSL,\n};\n\nlet mongoUri = `${config.dbServer}/${config.dbName}?`;\nif (config.dbAuthSource) mongoUri += `authSource=${config.dbAuthSource}&`;\nif (config.dbTsl) mongoUri += `tls=true&`;\nif (config.dbReplicaSet) mongoUri += `replicaSet=${config.dbReplicaSet}`;\n\nconst connectDB = async () => {\n  try {\n    await mongoose.connect(mongoUri, {\n      user: config.dbUser,\n      pass: config.dbPassword,\n    });\n    console.log(`Conectado ao MongoDB`);\n    console.log(` - Server: ${config.dbServer}`);\n    console.log(` - User: ${config.dbUser}`);\n    console.log(` - Database: ${config.dbName}`);\n  } catch (err) {\n    console.error(`Erro ao conectar ao MongoDB ${config.dbName}`, err);\n    process.exit(1); // Encerra o processo com falha\n  }\n};\n\nmodule.exports = { connectDB };\n",
  "tipo": "estatico",
  "prompt": "Desenvolva um módulo que estabelece uma conexão com um banco de dados MongoDB utilizando a biblioteca Mongoose. O módulo deve configurar a URI de conexão com base em variáveis de ambiente que especificam o servidor do banco de dados, usuário, senha, nome do banco, fonte de autenticação, conjunto de réplicas e se a conexão deve usar TLS. A função de conexão deve tentar conectar ao banco de dados e, em caso de sucesso, exibir informações sobre a conexão. Se a conexão falhar, deve registrar um erro e encerrar o processo. O módulo deve exportar a função de conexão para que possa ser utilizada em outras partes do aplicativo.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 150,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e479a0ce90cfd22c8e4"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "Arquivo.js",
  "caminho": "backend/src/models",
  "conteudo": "const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\n\nconst arquivoSchema = new Schema({\n  projeto: {\n    type: Schema.Types.ObjectId,\n    ref: 'Projeto',\n    required: true\n  },\n  nome: {\n    type: String,\n    required: true\n  },\n  caminho: {\n    type: String,\n    required: true\n  },\n  conteudo: {\n    type: String,\n  },\n  tipo: {\n    type: String,\n    enum: ['estatico', 'dinamico'],\n    required: true\n  },\n  prompt: {\n    type: String,\n    required: true\n  },\n  pascalCase: {\n    type: Boolean,\n    default: false\n  },\n  nomeConcatenado: {\n    type: Boolean,\n    default: false\n  },\n  ordem: {\n    type: Number,\n    required: true\n  },\n});\n\nmodule.exports = mongoose.model('Arquivo', arquivoSchema);\n",
  "tipo": "estatico",
  "prompt": "Desenvolva um modelo de dados utilizando Mongoose para representar um arquivo dentro de um projeto. O modelo deve incluir os seguintes campos: uma referência obrigatória ao projeto ao qual o arquivo pertence, o nome do arquivo que é uma string obrigatória, o caminho do arquivo que também deve ser uma string obrigatória, o conteúdo do arquivo que é uma string opcional, e um tipo que deve ser uma string obrigatória com valores limitados a 'estatico' ou 'dinamico'. Além disso, deve haver um campo para um prompt que é uma string obrigatória, um campo booleano para indicar se o nome está em PascalCase com valor padrão como falso, outro campo booleano para indicar se o nome é concatenado com valor padrão como falso, e um campo numérico obrigatório para definir a ordem do arquivo. O modelo deve ser exportado para uso em outras partes da aplicação.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 160,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e4a9a0ce90cfd22c8e6"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "Projeto.js",
  "caminho": "backend/src/models",
  "conteudo": "const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\n\nconst projetoSchema = new Schema({\n  nome: {\n    type: String,\n    required: true\n  },\n  status: {\n    type: String,\n    required: true,\n    enum: ['ativo', 'inativo']\n  },\n  prompt: {\n    type: String,\n    required: true\n  },\n});\n\nmodule.exports = mongoose.model('Projeto', projetoSchema);\n",
  "tipo": "estatico",
  "prompt": "Desenvolva um modelo de dados utilizando Mongoose para um projeto, que inclua um esquema com três campos: 'nome', que deve ser uma string obrigatória; 'status', que deve ser uma string obrigatória e pode ter apenas os valores 'ativo' ou 'inativo'; e 'prompt', que também deve ser uma string obrigatória. O modelo deve ser exportado para ser utilizado em outras partes da aplicação.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 170,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e4f9a0ce90cfd22c8e8"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "arquivoRoutes.js",
  "caminho": "backend/src/routes",
  "conteudo": "const express = require('express');\nconst router = express.Router();\nconst  Arquivo  = require(\"../models/Arquivo\")\n\n// Create a new Arquivo\nrouter.post('/', async (req, res) => {\n  try {\n    const novoArquivo = new Arquivo(req.body);\n    const arquivoSalvo = await novoArquivo.save();\n    res.status(201).json(arquivoSalvo);\n  } catch (err) {\n    res.status(400).json({ error: err.message });\n  }\n});\n\n// Read all Arquivos\nrouter.get('/', async (req, res) => {\n  try {\n    const arquivos = await Arquivo.find().populate('projeto');\n    res.status(200).json(arquivos);\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Read a single Arquivo by ID\nrouter.get('/:id', async (req, res) => {\n  try {\n    const arquivo = await Arquivo.findById(req.params.id).populate('projeto');\n    if (!arquivo) {\n      return res.status(404).json({ error: 'Arquivo not found' });\n    }\n    res.status(200).json(arquivo);\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Update an Arquivo by ID\nrouter.put('/:id', async (req, res) => {\n  try {\n    const arquivoAtualizado = await Arquivo.findByIdAndUpdate(\n      req.params.id,\n      req.body,\n      { new: true, runValidators: true }\n    );\n    if (!arquivoAtualizado) {\n      return res.status(404).json({ error: 'Arquivo not found' });\n    }\n    res.status(200).json(arquivoAtualizado);\n  } catch (err) {\n    res.status(400).json({ error: err.message });\n  }\n});\n\n// Delete an Arquivo by ID\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const arquivoDeletado = await Arquivo.findByIdAndDelete(req.params.id);\n    if (!arquivoDeletado) {\n      return res.status(404).json({ error: 'Arquivo not found' });\n    }\n    res.status(200).json({ message: 'Arquivo deleted successfully' });\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\nmodule.exports = router",
  "tipo": "estatico",
  "prompt": "Desenvolva uma API RESTful utilizando Express para gerenciar um recurso chamado \"Arquivo\". A API deve permitir as seguintes operações: \n\n1. Criar um novo Arquivo através de uma requisição POST, onde os dados do Arquivo são enviados no corpo da requisição e, em caso de sucesso, retorna o Arquivo criado com status 201. Em caso de erro, deve retornar um status 400 com a mensagem de erro.\n\n2. Listar todos os Arquivos com uma requisição GET, retornando todos os registros com status 200. Se ocorrer um erro, deve retornar um status 500 com a mensagem de erro.\n\n3. Recuperar um Arquivo específico por ID com uma requisição GET, retornando o Arquivo correspondente com status 200. Se o Arquivo não for encontrado, deve retornar um status 404 com uma mensagem de erro. Em caso de erro, deve retornar um status 500 com a mensagem de erro.\n\n4. Atualizar um Arquivo existente por ID através de uma requisição PUT, onde os dados atualizados são enviados no corpo da requisição. Se o Arquivo for encontrado e atualizado com sucesso, deve retornar o Arquivo atualizado com status 200. Se não for encontrado, deve retornar um status 404 com uma mensagem de erro. Em caso de erro, deve retornar um status 400 com a mensagem de erro.\n\n5. Deletar um Arquivo por ID com uma requisição DELETE, retornando uma mensagem de sucesso com status 200 se o Arquivo for deletado. Se não for encontrado, deve retornar um status 404 com uma mensagem de erro. Em caso de erro, deve retornar um status 500 com a mensagem de erro.\n\nA API deve utilizar um modelo de dados chamado \"Arquivo\" que é importado de um arquivo de modelo e deve incluir a funcionalidade de popular um campo relacionado chamado \"projeto\".",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 180,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e509a0ce90cfd22c8ea"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "clonarCodigoRoutes.js",
  "caminho": "backend/src/routes",
  "conteudo": "const express = require('express');\nconst router = express.Router();\nconst { clonarCodigo } = require('../controllers/clonarCodigoController');\n\nrouter.post('/', clonarCodigo);\n\nmodule.exports = router;\n",
  "tipo": "estatico",
  "prompt": "Crie uma rota POST utilizando o framework Express, que ao ser acessada, invoca a função 'clonarCodigo' definida em um controlador específico. Esta rota deve ser exportada para ser utilizada em outras partes da aplicação.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 190,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e519a0ce90cfd22c8ec"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "codeGeneratorRoutes.js",
  "caminho": "backend/src/routes",
  "conteudo": "const express = require('express');\nconst router = express.Router();\nconst { createCode } = require('../controllers/codeGeneratorController');\n\nrouter.post('/', createCode);\n\nmodule.exports = router;\n",
  "tipo": "estatico",
  "prompt": "Crie uma rota para um aplicativo Express que escuta requisições POST na raiz do endpoint. Esta rota deve invocar a função `createCode` do controlador `codeGeneratorController` para processar as requisições recebidas. O módulo deve ser exportado para que possa ser utilizado em outras partes do aplicativo.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 200,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e539a0ce90cfd22c8ee"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "projetoRoutes.js",
  "caminho": "backend/src/routes",
  "conteudo": "const express = require('express');\nconst router = express.Router();\nconst Projeto = require(\"../models/Projeto\")\n\nrouter.post('/', async (req, res) => {\n  try {\n    const novoProjeto = new Projeto(req.body);\n    const projetoSalvo = await novoProjeto.save();\n    res.status(201).json(projetoSalvo);\n  } catch (err) {\n    res.status(400).json({ error: err.message });\n  }\n});\n\n// Read all Projetos\nrouter.get('/', async (req, res) => {\n  try {\n    const projetos = await Projeto.find();\n    res.status(200).json(projetos);\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Read a single Projeto by ID\nrouter.get('/:id', async (req, res) => {\n  try {\n    const projeto = await Projeto.findById(req.params.id);\n    if (!projeto) {\n      return res.status(404).json({ error: 'Projeto not found' });\n    }\n    res.status(200).json(projeto);\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Update a Projeto by ID\nrouter.put('/:id', async (req, res) => {\n  try {\n    const projetoAtualizado = await Projeto.findByIdAndUpdate(\n      req.params.id,\n      req.body,\n      { new: true, runValidators: true }\n    );\n    if (!projetoAtualizado) {\n      return res.status(404).json({ error: 'Projeto not found' });\n    }\n    res.status(200).json(projetoAtualizado);\n  } catch (err) {\n    res.status(400).json({ error: err.message });\n  }\n});\n\n// Delete a Projeto by ID\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const projetoDeletado = await Projeto.findByIdAndDelete(req.params.id);\n    if (!projetoDeletado) {\n      return res.status(404).json({ error: 'Projeto not found' });\n    }\n    res.status(200).json({ message: 'Projeto deleted successfully' });\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\nmodule.exports = router",
  "tipo": "estatico",
  "prompt": "Desenvolva uma API RESTful utilizando Express para gerenciar projetos. A API deve permitir as seguintes operações: criar um novo projeto através de uma requisição POST, listar todos os projetos com uma requisição GET, buscar um projeto específico por ID com uma requisição GET, atualizar um projeto existente por ID utilizando uma requisição PUT, e deletar um projeto por ID com uma requisição DELETE. As respostas devem incluir códigos de status apropriados e mensagens de erro em caso de falhas, garantindo que as operações sejam realizadas de forma assíncrona e que as validações necessárias sejam aplicadas.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 210,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e549a0ce90cfd22c8f0"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "server.js",
  "caminho": "backend/src",
  "conteudo": "const app = require('./app');\nconst PORT = process.env.PORT;\n\napp.listen(PORT, () => {\n  console.log(`Servidor rodando na porta ${PORT}`);\n});\n",
  "tipo": "estatico",
  "prompt": "Crie um servidor que utilize um aplicativo importado de um módulo externo. O servidor deve escutar em uma porta definida por uma variável de ambiente e, ao iniciar, deve exibir uma mensagem no console informando que está em execução na porta especificada.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 220,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e589a0ce90cfd22c8f2"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "chatGptService.js",
  "caminho": "backend/src/services",
  "conteudo": "const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));\n\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\nexports.generateCode = async (messages, retries = 3, backoff = 300) => {\n  try {\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`\n      },\n      body: JSON.stringify({\n        model: 'gpt-4o-mini', // Atualize para o modelo correto\n        messages,\n        temperature: 0\n      })\n    });\n\n    if (response.status === 429) { // Rate limit excedido\n      if (retries > 0) {\n        console.warn(`Rate limit atingido. Tentando novamente em ${backoff}ms...`);\n        await sleep(backoff);\n        return exports.generateCode(messages, retries - 1, backoff * 2);\n      } else {\n        throw new Error('Taxa de requisições excedida. Tente novamente mais tarde.');\n      }\n    }\n\n    if (!response.ok) {\n      const errorData = await response.text();\n      throw new Error(`Erro na API do ChatGPT: ${response.status} - ${errorData}`);\n    }\n\n    const data = await response.json();\n\n    if (data.choices && data.choices.length > 0) {\n      return data.choices[0].message.content.trim();\n    } else {\n      throw new Error('Nenhuma resposta recebida do ChatGPT.');\n    }\n  } catch (error) {\n    console.error('Erro ao chamar a API do ChatGPT:', error);\n    throw error;\n  }\n};\n",
  "tipo": "estatico",
  "prompt": "Desenvolva uma função assíncrona que se conecta à API do OpenAI para gerar código com base em mensagens fornecidas. A função deve permitir um número configurável de tentativas em caso de falha, implementando um mecanismo de espera exponencial em caso de limite de taxa excedido. A função deve enviar uma solicitação POST com um cabeçalho de autorização que utiliza uma chave de API armazenada em variáveis de ambiente. Caso a resposta da API não seja bem-sucedida, a função deve lançar erros apropriados, incluindo mensagens de erro detalhadas. Se a resposta contiver escolhas, a função deve retornar o conteúdo da primeira escolha, caso contrário, deve lançar um erro indicando que nenhuma resposta foi recebida.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 230,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e599a0ce90cfd22c8f4"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "fileUtils.js",
  "caminho": "backend/src/utils",
  "conteudo": "const fs = require('fs').promises;\n\nexports.ensureDirExists = async (dirPath) => {\n  await fs.mkdir(dirPath, { recursive: true });\n};\n",
  "tipo": "estatico",
  "prompt": "Desenvolva uma função assíncrona que garante a criação de um diretório especificado por um caminho. Se o diretório já existir, a função não fará nada; caso contrário, ela criará o diretório e todos os diretórios pai necessários de forma recursiva. Utilize a biblioteca de sistema de arquivos do Node.js para realizar essa operação.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 240,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e5b9a0ce90cfd22c8f6"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "namingUtils.js",
  "caminho": "backend/src/utils",
  "conteudo": "exports.toCamelCase = (str) => {\n  return str.charAt(0).toLowerCase() + str.slice(1);\n};\n\nexports.removeCodeBlockMarkers = (code) => {\n  return code.split('\\n')\n    .filter(line => !line.startsWith('```'))\n    .join('\\n')\n    .trim();\n};\n",
  "tipo": "estatico",
  "prompt": "Desenvolva uma função que converte a primeira letra de uma string para minúscula, mantendo o restante da string inalterado. Além disso, crie uma função que remove marcadores de bloco de código (linhas que começam com três crases) de um texto, filtrando essas linhas e retornando o texto resultante sem espaços em branco no início ou no final. Ambas as funções devem ser exportadas para uso em outros módulos.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 250,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e5c9a0ce90cfd22c8f8"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": ".env",
  "caminho": "frontend",
  "conteudo": "",
  "tipo": "dinamico",
  "prompt": "gere uma variavel de url base para a api",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 260,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e5f9a0ce90cfd22c8fa"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": ".gitignore",
  "caminho": "frontend",
  "conteudo": "# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n",
  "tipo": "estatico",
  "prompt": "Crie um arquivo de configuração para ignorar arquivos e diretórios específicos em um projeto, incluindo logs de execução, diretórios de dependências, arquivos de distribuição e configurações de editores. O arquivo deve excluir todos os arquivos com a extensão .log, diretórios como node_modules e dist, além de arquivos de configuração de editores como .vscode e .idea, mantendo apenas o arquivo extensions.json dentro do diretório .vscode. Além disso, deve ignorar arquivos de sistema e de projeto específicos, como .DS_Store e arquivos de solução do Visual Studio.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 270,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e609a0ce90cfd22c8fc"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "README.md",
  "caminho": "frontend",
  "conteudo": "# React + Vite\n\nThis template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.\n\nCurrently, two official plugins are available:\n\n- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh\n- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh\n",
  "tipo": "estatico",
  "prompt": "Crie um projeto básico utilizando React com Vite, que inclua suporte para Hot Module Replacement (HMR) e algumas regras de ESLint. O projeto deve permitir a escolha entre dois plugins oficiais para integração do React: um que utiliza Babel para o Fast Refresh e outro que utiliza SWC para o mesmo propósito.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 280,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e629a0ce90cfd22c8fe"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "eslint.config.js",
  "caminho": "frontend",
  "conteudo": "import js from '@eslint/js'\nimport globals from 'globals'\nimport react from 'eslint-plugin-react'\nimport reactHooks from 'eslint-plugin-react-hooks'\nimport reactRefresh from 'eslint-plugin-react-refresh'\n\nexport default [\n  { ignores: ['dist'] },\n  {\n    files: ['**/*.{js,jsx}'],\n    languageOptions: {\n      ecmaVersion: 2020,\n      globals: globals.browser,\n      parserOptions: {\n        ecmaVersion: 'latest',\n        ecmaFeatures: { jsx: true },\n        sourceType: 'module',\n      },\n    },\n    settings: { react: { version: '18.3' } },\n    plugins: {\n      react,\n      'react-hooks': reactHooks,\n      'react-refresh': reactRefresh,\n    },\n    rules: {\n      ...js.configs.recommended.rules,\n      ...react.configs.recommended.rules,\n      ...react.configs['jsx-runtime'].rules,\n      ...reactHooks.configs.recommended.rules,\n      'react/jsx-no-target-blank': 'off',\n      'react-refresh/only-export-components': [\n        'warn',\n        { allowConstantExport: true },\n      ],\n    },\n  },\n]\n",
  "tipo": "estatico",
  "prompt": "Crie uma configuração de linting para um projeto JavaScript que utiliza React, incluindo suporte para JSX e hooks. A configuração deve ignorar a pasta 'dist' e aplicar regras recomendadas do ESLint, do plugin React e do plugin de hooks do React. Defina a versão do ECMAScript como 2020 e permita o uso de módulos. Inclua configurações específicas para a versão 18.3 do React e ajuste regras específicas, como desativar a regra que proíbe o uso de 'target=\"_blank\"' em links JSX e emitir um aviso para a regra que exige a exportação de componentes.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 290,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e649a0ce90cfd22c900"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "index.html",
  "caminho": "frontend",
  "conteudo": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Vite + React</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"/src/main.jsx\"></script>\n  </body>\n</html>\n",
  "tipo": "estatico",
  "prompt": "Crie um documento HTML que define a estrutura básica de uma página web. O documento deve incluir a declaração do tipo de documento como HTML5 e especificar o idioma como inglês. No cabeçalho, adicione a codificação de caracteres UTF-8, um ícone de favicon no formato SVG, e uma meta tag para garantir que a página seja responsiva em diferentes dispositivos. O título da página deve ser \"Vite + React\". No corpo do documento, inclua uma div com o ID \"root\", que servirá como ponto de montagem para uma aplicação React. Por fim, insira um script que carrega um arquivo JavaScript principal localizado em \"/src/main.jsx\" como um módulo.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 300,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e669a0ce90cfd22c902"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "package.json",
  "caminho": "frontend",
  "conteudo": "{\n  \"name\": \"frontend\",\n  \"private\": true,\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\",\n    \"lint\": \"eslint .\",\n    \"preview\": \"vite preview\"\n  },\n  \"dependencies\": {\n    \"@tanstack/react-query\": \"^5.62.7\",\n    \"react\": \"^18.3.1\",\n    \"react-dom\": \"^18.3.1\",\n    \"react-hook-form\": \"^7.54.0\",\n    \"react-router-dom\": \"^6.28.0\",\n    \"zod\": \"^3.24.1\"\n  },\n  \"devDependencies\": {\n    \"@eslint/js\": \"^9.15.0\",\n    \"@types/react\": \"^18.3.12\",\n    \"@types/react-dom\": \"^18.3.1\",\n    \"@vitejs/plugin-react\": \"^4.3.4\",\n    \"autoprefixer\": \"^10.4.20\",\n    \"eslint\": \"^9.15.0\",\n    \"eslint-plugin-react\": \"^7.37.2\",\n    \"eslint-plugin-react-hooks\": \"^5.0.0\",\n    \"eslint-plugin-react-refresh\": \"^0.4.14\",\n    \"globals\": \"^15.12.0\",\n    \"postcss\": \"^8.4.49\",\n    \"tailwindcss\": \"^3.4.16\",\n    \"vite\": \"^6.0.1\"\n  }\n}\n",
  "tipo": "estatico",
  "prompt": "Descreva um arquivo de configuração de projeto para um aplicativo frontend que utiliza React. O projeto é privado e possui uma versão inicial. Especifique que ele utiliza módulos ECMAScript. Inclua scripts para desenvolvimento, construção, linting e pré-visualização do aplicativo. Liste as dependências principais, incluindo bibliotecas para gerenciamento de estado, formulários, roteamento e validação. Adicione também as dependências de desenvolvimento, que incluem ferramentas para linting, tipos TypeScript, plugins para Vite e Tailwind CSS, além de outras bibliotecas úteis para o desenvolvimento e estilização do projeto.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 310,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e679a0ce90cfd22c904"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "postcss.config.js",
  "caminho": "frontend",
  "conteudo": "export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n",
  "tipo": "estatico",
  "prompt": "Crie um arquivo de configuração que exporta um objeto padrão contendo uma propriedade chamada \"plugins\". Esta propriedade deve ser um objeto que inclui dois plugins: \"tailwindcss\" e \"autoprefixer\", ambos configurados com objetos vazios. O propósito deste arquivo é integrar e configurar esses plugins para serem utilizados em um projeto de desenvolvimento web, permitindo o uso de estilos do Tailwind CSS e a adição automática de prefixos CSS para compatibilidade entre navegadores.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 320,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e699a0ce90cfd22c906"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "App.jsx",
  "caminho": "frontend/src",
  "conteudo": "import React from 'react';\nimport CodeGenerator from './components/CodeGenerator';\n\n\nconst App = () => {\n  return (\n    <div >\n      <h1>Assistente de Geração de Formulários e Cards</h1>\n      <CodeGenerator />\n    </div>\n  );\n};\n\nexport default App;\n",
  "tipo": "dinamico",
  "prompt": "criar as rotas da aplicação usando react-router-dom",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 450,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e6b9a0ce90cfd22c908"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "CodeGenerator.css",
  "caminho": "frontend/src/components",
  "conteudo": ".code-generator {\n  max-width: 600px;\n  margin: 0 auto;\n  padding: 20px;\n  border: 1px solid #ccc;\n  border-radius: 8px;\n  background-color: #f9f9f9;\n}\n\n.code-generator h2 {\n  text-align: center;\n  margin-bottom: 20px;\n}\n\n.form-group {\n  margin-bottom: 15px;\n}\n\n.form-control {\n  width: 100%;\n  padding: 10px;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n}\n\n.btn {\n  display: block;\n  width: 100%;\n  padding: 10px;\n  background-color: #007bff;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n\n.btn:hover {\n  background-color: #0056b3;\n}\n\n.message {\n  margin-top: 20px;\n  text-align: center;\n  color: green;\n}",
  "tipo": "estatico",
  "prompt": "Desenvolva um componente de interface de usuário para um gerador de código, que deve ter um layout centralizado com uma largura máxima de 600 pixels. O componente deve incluir um título centralizado, um formulário com grupos de campos que possuem margens inferiores, e campos de entrada que ocupam 100% da largura disponível, com preenchimento e bordas arredondadas. Adicione um botão que se expanda para ocupar toda a largura, com um fundo azul e texto branco, que muda para um tom mais escuro de azul ao passar o mouse. Inclua uma área para mensagens que apareça abaixo do formulário, centralizada e com texto em verde, para exibir feedback ao usuário.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 340,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e6d9a0ce90cfd22c90a"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "CodeGenerator.jsx",
  "caminho": "frontend/src/components",
  "conteudo": "import React, { useState } from 'react';\nimport './CodeGenerator.css';\n\nconst CodeGenerator = () => {\n  const [projetoId, setProjetoId] = useState('6754cd3f760eb6acd676c65e');\n  const [nome, setNome] = useState('');\n  const [prompt, setPrompt] = useState('');\n\n  const [message, setMessage] = useState('');\n\n  const handleGenerateCode = async () => {\n    setMessage('Gerando código...');\n\n    const response = await fetch('http://localhost:5000/api/generate-code', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ projetoId, nome, prompt }),\n    });\n\n    const data = await response.json();\n    setMessage(data.message || data.error);\n  };\n\n  return (\n    <div className=\"code-generator\">\n      <h2>Gerador de Código</h2>\n      <div className=\"form-group\">\n        <input\n          type=\"text\"\n          placeholder=\"Nome do Projeto que será criado\"\n          value={projetoId}\n          onChange={(e) => setProjetoId(e.target.value)}\n          className=\"form-control\"\n        />\n      </div>\n      <div className=\"form-group\">\n        <input\n          type=\"text\"\n          placeholder=\"Nome do Projeto\"\n          value={nome}\n          onChange={(e) => setNome(e.target.value)}\n          className=\"form-control\"\n        />\n      </div>\n      <div className=\"form-group\">\n        <textarea\n          placeholder=\"Descrição dos campos e validações necessárias\"\n          value={prompt}\n          onChange={(e) => setPrompt(e.target.value)}\n          className=\"form-control\"\n        />\n      </div>\n      <button onClick={handleGenerateCode} className=\"btn btn-primary\">Gerar Código</button>\n      {message && <p className=\"message\">{message}</p>}\n    </div>\n  );\n};\n\nexport default CodeGenerator;\n",
  "tipo": "estatico",
  "prompt": "Desenvolva um componente React chamado \"CodeGenerator\" que permite aos usuários gerar código para um projeto. O componente deve incluir campos de entrada para o ID do projeto, o nome do projeto e uma descrição dos campos e validações necessárias. Ao clicar em um botão, o componente deve enviar uma solicitação POST para uma API local, passando os dados inseridos pelo usuário. O componente deve exibir uma mensagem de status enquanto o código está sendo gerado e mostrar uma mensagem de sucesso ou erro com base na resposta da API. O layout deve ser estilizado com uma classe CSS específica.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 350,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e6e9a0ce90cfd22c90c"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "arquivoForm.jsx",
  "caminho": "frontend/src/components",
  "conteudo": "",
  "tipo": "dinamico",
  "prompt": "Criar formulario de arquivo (criar, alterar) usando zod react-hook-form",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 360,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e709a0ce90cfd22c90e"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "projetoForm.jsx",
  "caminho": "frontend/src/components",
  "conteudo": "",
  "tipo": "dinamico",
  "prompt": "criar formulario correspodente a todos os campos da model usando zod e react-hook-rom ",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 370,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e719a0ce90cfd22c910"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "index.css",
  "caminho": "frontend/src",
  "conteudo": "@tailwind base;\n@tailwind components;\n@tailwind utilities;",
  "tipo": "estatico",
  "prompt": "Crie um arquivo de estilo que importe as diretrizes básicas, componentes e utilitários do Tailwind CSS, garantindo que as classes de estilo sejam aplicadas de acordo com as convenções do framework para estilização de uma aplicação web.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 380,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e729a0ce90cfd22c912"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "main.jsx",
  "caminho": "frontend/src",
  "conteudo": "import React from 'react';\nimport { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport App from './App.jsx';\nimport \"./index.css\"\n\ncreateRoot(document.getElementById('root')).render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);",
  "tipo": "estatico",
  "prompt": "Desenvolva uma aplicação React que renderiza um componente principal chamado \"App\" dentro de um elemento HTML com o ID \"root\". A renderização deve ocorrer em modo estrito, que ajuda a identificar problemas potenciais no código. Além disso, inclua um arquivo de estilo CSS para a aplicação.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 390,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e739a0ce90cfd22c914"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "projetos.jsx",
  "caminho": "frontend/src/pages",
  "conteudo": "",
  "tipo": "dinamico",
  "prompt": "Crie a pagina de projetos, com a lista de projetos com as opções de adicionar novo, editar, excluir e clonar. Quando clicar em editar, clonar e adicionar navegar para a rota projetosDetails.jsx",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 425,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e759a0ce90cfd22c916"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "projetosDetails.jsx",
  "caminho": "frontend/src/pages",
  "conteudo": "",
  "tipo": "dinamico",
  "prompt": "Criar a pagina de detalhes do projeto nessa pagina haverá um formulário que sera possivel adicionar ou alterar com todos os campos da model. Lembre se de usar tastaq-react-query",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 435,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e769a0ce90cfd22c918"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "arquivoService.js",
  "caminho": "frontend/src/services",
  "conteudo": "",
  "tipo": "dinamico",
  "prompt": "Crie as chamadas api delete, list, create e update",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 420,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e779a0ce90cfd22c91a"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "projetoService.js",
  "caminho": "frontend/src/services",
  "conteudo": "",
  "tipo": "dinamico",
  "prompt": "Crie as chamadas api delete, list, create e update",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 430,
  "__v": 0
},
{
  "_id": {
    "$oid": "675b2e789a0ce90cfd22c91c"
  },
  "projeto": {
    "$oid": "675b2e259a0ce90cfd22c8c4"
  },
  "nome": "tailwind.config.js",
  "caminho": "frontend",
  "conteudo": "/** @type {import('tailwindcss').Config} */\nexport default {\n  content: [\n    \"./index.html\",\n    \"./src/**/*.{js,ts,jsx,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n\n",
  "tipo": "estatico",
  "prompt": "Crie uma configuração para o Tailwind CSS que especifique os arquivos de conteúdo a serem analisados, incluindo um arquivo HTML e todos os arquivos JavaScript e TypeScript dentro da pasta \"src\". A configuração deve permitir a extensão do tema, mas não deve incluir plugins adicionais.",
  "pascalCase": false,
  "nomeConcatenado": false,
  "ordem": 440,
  "__v": 0
}]